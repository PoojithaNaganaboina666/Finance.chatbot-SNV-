# -*- coding: utf-8 -*-
"""Finance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1urxhSqZUrY37BjPMKsFXZnnZHnUcHd3W
"""



!pip -q install gradio pandas sqlalchemy requests

# Single-cell Google Colab: Personal Finance Chatbot (Transactions removed)
# Features included:
# 1) Account management (create/list)
# 2) Bills & reminders (add/list/mark-notified)
# 3) Savings goals & projections (create/deposit/list/project)
# 4) Optional NLP parsing via IBM Granite 3.3 2B Instruct on Hugging Face

# -------------------
# Install dependencies
# -------------------
!pip -q install gradio pandas sqlalchemy requests

# -------------------
# Imports & config
# -------------------
import os, re, json, datetime
from pathlib import Path
from typing import Optional, Dict, Any
import pandas as pd
import requests
import gradio as gr
from sqlalchemy import create_engine, Column, Integer, String, Float, Date, DateTime, Table, MetaData, select, and_, func

# Config
DB_PATH = "/content/pfinance_chatbot.db"
HF_MODEL = "ibm-granite/granite-3.3-2b-instruct"
HF_API_URL = f"https://api-inference.huggingface.co/models/{HF_MODEL}"

# -------------------
# Setup SQLite via SQLAlchemy Core
# -------------------
engine = create_engine(f"sqlite:///{DB_PATH}", connect_args={"check_same_thread": False})
meta = MetaData()

accounts_table = Table(
    "accounts", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("name", String, nullable=False, unique=True),
    Column("type", String, nullable=True),  # e.g., 'bank', 'cash', 'card'
    Column("balance", Float, nullable=False, default=0.0)
)

# Transactions removed entirely to satisfy "Option A"

bills_table = Table(
    "bills", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("account_id", Integer, nullable=False),
    Column("name", String, nullable=False),
    Column("amount", Float, nullable=False),
    Column("due_date", Date, nullable=False),
    Column("repeat", String, nullable=True),  # e.g., 'monthly', 'yearly', or None
    Column("notified", Integer, nullable=False, default=0)  # 0/1 flag
)

savings_goals_table = Table(
    "savings_goals", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("name", String, nullable=False),
    Column("target_amount", Float, nullable=False),
    Column("current_amount", Float, nullable=False, default=0.0),
    Column("target_date", Date, nullable=True),
    Column("account_id", Integer, nullable=True)
)

meta.create_all(engine)

# -------------------
# DB helper functions
# -------------------
def create_account(name: str, acc_type: str = "bank", initial_balance: float = 0.0) -> str:
    name = str(name).strip()
    if not name:
        return "Account name required."
    with engine.connect() as conn:
        # check duplicate by lower(name)
        stmt = select(accounts_table.c.id).where(func.lower(accounts_table.c.name) == name.lower())
        res = conn.execute(stmt).fetchone()
        if res:
            return f"Account with name '{name}' already exists."
        ins = accounts_table.insert().values(name=name, type=acc_type, balance=float(initial_balance))
        conn.execute(ins)
    return f"Account '{name}' created with balance ₹{float(initial_balance):,.2f}"

def list_accounts() -> str:
    with engine.connect() as conn:
        stmt = select(accounts_table)
        rows = conn.execute(stmt).fetchall()
    if not rows:
        return "No accounts yet."
    lines = []
    for r in rows:
        lines.append(f"ID:{r.id} | {r.name} ({r.type}) | Balance: ₹{r.balance:,.2f}")
    return "\n".join(lines)

def get_account_by_name_or_id(identifier) -> Optional[Dict[str,Any]]:
    if identifier is None:
        return None
    identifier = str(identifier).strip()
    with engine.connect() as conn:
        if identifier.isdigit():
            stmt = select(accounts_table).where(accounts_table.c.id == int(identifier))
        else:
            stmt = select(accounts_table).where(func.lower(accounts_table.c.name) == identifier.lower())
        row = conn.execute(stmt).fetchone()
    if row:
        return dict(row)
    return None

def update_account_balance(account_id: int, delta: float) -> float:
    with engine.begin() as conn:
        stmt = select(accounts_table.c.balance).where(accounts_table.c.id == int(account_id))
        row = conn.execute(stmt).fetchone()
        if not row:
            raise ValueError("Account not found")
        new_bal = float(row.balance) + float(delta)
        upd = accounts_table.update().where(accounts_table.c.id == int(account_id)).values(balance=new_bal)
        conn.execute(upd)
    return new_bal

# -------------------
# Bills helpers
# -------------------
def add_bill(account_identifier, name, amount, due_date_str, repeat=None):
    acct = get_account_by_name_or_id(account_identifier)
    if not acct:
        return f"Account '{account_identifier}' not found."
    try:
        due_date = pd.to_datetime(due_date_str).date()
    except:
        return "Invalid date. Use YYYY-MM-DD."
    with engine.begin() as conn:
        conn.execute(bills_table.insert().values(account_id=acct["id"], name=name, amount=float(amount), due_date=due_date, repeat=repeat, notified=0))
    return f"Bill '{name}' of ₹{float(amount):,.2f} added for account '{acct['name']}' due {due_date.isoformat()}"

def upcoming_bills(days_ahead=7):
    today = datetime.date.today()
    end = today + datetime.timedelta(days=int(days_ahead))
    with engine.connect() as conn:
        stmt = select(bills_table.c.id, bills_table.c.name, bills_table.c.amount, bills_table.c.due_date, accounts_table.c.name.label("account_name")).select_from(
            bills_table.join(accounts_table, bills_table.c.account_id == accounts_table.c.id)
        ).where(and_(bills_table.c.due_date >= today, bills_table.c.due_date <= end)).order_by(bills_table.c.due_date.asc())
        rows = conn.execute(stmt).fetchall()
    if not rows:
        return f"No bills due in next {days_ahead} days."
    lines = []
    for r in rows:
        lines.append(f"ID:{r.id} | {r.name} | Account:{r.account_name} | Due:{r.due_date.isoformat()} | ₹{r.amount:,.2f}")
    return "\n".join(lines)

def mark_bill_notified(bill_id):
    with engine.begin() as conn:
        stmt = select(bills_table).where(bills_table.c.id == int(bill_id))
        r = conn.execute(stmt).fetchone()
        if not r:
            return "Bill not found."
        conn.execute(bills_table.update().where(bills_table.c.id == int(bill_id)).values(notified=1))
    return f"Marked bill {bill_id} as notified."

# -------------------
# Savings helpers
# -------------------
def create_savings_goal(name, target_amount, target_date_str=None, account_identifier=None):
    acct = None
    if account_identifier:
        acct = get_account_by_name_or_id(account_identifier)
        if not acct:
            return f"Account '{account_identifier}' not found."
    try:
        td = pd.to_datetime(target_date_str).date() if target_date_str else None
    except:
        return "Invalid target date, use YYYY-MM-DD or leave blank."
    with engine.begin() as conn:
        conn.execute(savings_goals_table.insert().values(name=name, target_amount=float(target_amount), current_amount=0.0, target_date=td, account_id=(acct["id"] if acct else None)))
    return f"Savings goal '{name}' created for ₹{float(target_amount):,.2f}" + (f" by {td.isoformat()}" if td else "")

def deposit_to_goal(goal_id, amount):
    with engine.begin() as conn:
        stmt = select(savings_goals_table).where(savings_goals_table.c.id == int(goal_id))
        row = conn.execute(stmt).fetchone()
        if not row:
            return "Goal not found."
        new_amt = float(row.current_amount) + float(amount)
        conn.execute(savings_goals_table.update().where(savings_goals_table.c.id == int(goal_id)).values(current_amount=new_amt))
    return f"Deposited ₹{float(amount):,.2f} to goal '{row.name}'. Current: ₹{new_amt:,.2f} / ₹{row.target_amount:,.2f}"

def list_goals():
    with engine.connect() as conn:
        rows = conn.execute(select(savings_goals_table)).fetchall()
    if not rows:
        return "No savings goals yet."
    lines = []
    for r in rows:
        td = r.target_date.isoformat() if r.target_date else "N/A"
        lines.append(f"ID:{r.id} | {r.name} | ₹{r.current_amount:,.2f} / ₹{r.target_amount:,.2f} | Target: {td}")
    return "\n".join(lines)

def project_savings_rate(goal_id):
    with engine.connect() as conn:
        goal = conn.execute(select(savings_goals_table).where(savings_goals_table.c.id == int(goal_id))).fetchone()
        if not goal:
            return "Goal not found."
        if not goal.target_date:
            return "Goal has no target date; set a target date to project savings rate."
        today = datetime.date.today()
        months = max(1, (goal.target_date.year - today.year) * 12 + (goal.target_date.month - today.month))
        remaining = float(goal.target_amount) - float(goal.current_amount)
        per_month = remaining / months
        # Transactions feature removed — recent income not available
        avg_monthly_income = 0.0
    return f"To reach ₹{goal.target_amount:,.2f} in {months} months you need to save ~₹{per_month:,.2f}/month. Recent avg monthly income: ₹{avg_monthly_income:,.2f}"

# -------------------
# Hugging Face model call (optional)
# -------------------
def call_hf_model(prompt: str, hf_token: str, max_tokens: int = 256, temperature: float = 0.0) -> str:
    if not hf_token:
        raise ValueError("No Hugging Face API token provided.")
    headers = {"Authorization": f"Bearer {hf_token}"}
    payload = {"inputs": prompt, "parameters": {"max_new_tokens": max_tokens, "temperature": temperature, "do_sample": False}, "options": {"use_cache": False}}
    resp = requests.post(HF_API_URL, headers=headers, json=payload, timeout=60)
    resp.raise_for_status()
    content = resp.json()
    if isinstance(content, list) and "generated_text" in content[0]:
        return content[0]["generated_text"]
    if isinstance(content, dict) and "generated_text" in content:
        return content["generated_text"]
    if isinstance(content, str):
        return content
    return json.dumps(content)

def parse_nl_command(text: str, hf_token: str):
    prompt = (
        "Extract a JSON object from the user's instruction. Output ONLY JSON. "
        "JSON fields: action (choose from: add_bill, create_account, create_goal, deposit_goal), "
        "account (name), amount (number), category, date (YYYY-MM-DD), note, related_account (name), bill_name, repeat (monthly/yearly/null), goal_name, target_amount, goal_id.\n\n"
        f"User: '''{text}'''\n\n"
        "Example: {\"action\":\"add_bill\",\"account\":\"Cash\",\"amount\":250,\"bill_name\":\"Internet\",\"date\":\"2025-11-17\",\"repeat\":null}\n"
        "If you can't determine a field, set it to null. Respond ONLY with JSON."
    )
    gen = call_hf_model(prompt, hf_token, max_tokens=300, temperature=0.0)
    m = re.search(r"\{.*\}", gen, flags=re.DOTALL)
    jtext = m.group(0) if m else gen.strip()
    try:
        parsed = json.loads(jtext)
        return parsed
    except Exception:
        # fallback heuristics
        amount_search = re.search(r"([0-9]+[,\d]*(?:\.\d+)?)", text.replace(',',''))
        amount = float(amount_search.group(1)) if amount_search else None
        if re.search(r"\b(bill|due|pay|payment)\b", text, flags=re.I):
            action = "add_bill"
        elif re.search(r"\b(create account|new account)\b", text, flags=re.I):
            action = "create_account"
        elif re.search(r"\b(goal|save for|savings goal)\b", text, flags=re.I):
            action = "create_goal"
        else:
            action = None
        return {"action": action, "account": None, "amount": amount, "category": None, "date": None, "note": text, "related_account": None}

# -------------------
# Gradio wrappers
# -------------------
def ui_create_account(name, acc_type, initial_balance):
    try:
        return create_account(name.strip(), acc_type.strip(), float(initial_balance))
    except Exception as e:
        return f"Error creating account: {e}"

def ui_list_accounts():
    try:
        return list_accounts()
    except Exception as e:
        return f"Error: {e}"

def ui_add_bill(account, name, amount, due_date, repeat):
    try:
        repeat_val = None if (repeat is None or repeat == "none") else repeat
        return add_bill(account, name, amount, due_date, repeat_val)
    except Exception as e:
        return f"Error: {e}"

def ui_upcoming_bills(days):
    try:
        return upcoming_bills(days)
    except Exception as e:
        return f"Error: {e}"

def ui_mark_bill(bill_id):
    try:
        return mark_bill_notified(int(bill_id))
    except Exception as e:
        return f"Error: {e}"

def ui_create_goal(name, target_amount, target_date, account):
    try:
        return create_savings_goal(name, target_amount, target_date or None, account or None)
    except Exception as e:
        return f"Error: {e}"

def ui_deposit_goal(goal_id, amount):
    try:
        return deposit_to_goal(goal_id, amount)
    except Exception as e:
        return f"Error: {e}"

def ui_list_goals():
    try:
        return list_goals()
    except Exception as e:
        return f"Error: {e}"

def ui_project_goal(goal_id):
    try:
        return project_savings_rate(goal_id)
    except Exception as e:
        return f"Error: {e}"

def ui_parse_nl_and_execute(text, hf_token):
    if not text or text.strip() == "":
        return "Enter a command."
    if not hf_token:
        return "HF token required for NLP parsing. Leave blank to use forms."
    try:
        parsed = parse_nl_command(text, hf_token)
    except Exception as e:
        return f"Error calling HF model: {e}"
    action = parsed.get("action")
    if action == "add_bill":
        return add_bill(parsed.get("account") or "Cash", parsed.get("bill_name") or "Bill", parsed.get("amount") or 0.0, parsed.get("date") or datetime.date.today().isoformat(), parsed.get("repeat"))
    if action == "create_account":
        return create_account(parsed.get("account") or "NewAcct", "bank", parsed.get("amount") or 0.0)
    if action == "create_goal":
        return create_savings_goal(parsed.get("goal_name") or "Goal", parsed.get("target_amount") or 0.0, parsed.get("date") or None, parsed.get("account") or None)
    if action == "deposit_goal":
        return deposit_to_goal(parsed.get("goal_id"), parsed.get("amount") or 0.0)
    return f"Couldn't interpret action from NLP: {parsed}"

# -------------------
# Gradio app layout (transactions removed)
# -------------------
with gr.Blocks() as demo:
    gr.Markdown("## Personal Finance Chatbot — Single Colab Cell (transactions removed)\n"
                "- Account management (create & list)\n"
                "- Bills & reminders (add / upcoming / mark notified)\n"
                "- Savings goals & projections\n"
                "- Optional: Natural-language parsing via IBM Granite 3.3 2B Instruct from Hugging Face. "
                "Paste your HF token below to enable NLP parsing.")
    with gr.Row():
        hf_token_input = gr.Textbox(label="Hugging Face API token (optional)", placeholder="hf_xxx", type="password")
    with gr.Tab("Account Management"):
        with gr.Row():
            acct_name = gr.Textbox(label="Account Name")
            acct_type = gr.Textbox(label="Account Type (bank/cash/card)", value="bank")
            acct_init = gr.Number(label="Initial Balance", value=0.0)
            create_acct_btn = gr.Button("Create Account")
            create_acct_out = gr.Textbox(label="Result", interactive=False)
            create_acct_btn.click(fn=ui_create_account, inputs=[acct_name, acct_type, acct_init], outputs=create_acct_out)
        with gr.Row():
            list_acct_btn = gr.Button("List Accounts")
            list_acct_out = gr.Textbox(label="Accounts", interactive=False)
            list_acct_btn.click(fn=ui_list_accounts, inputs=None, outputs=list_acct_out)

    with gr.Tab("Bills & Reminders"):
        with gr.Row():
            bill_acct = gr.Textbox(label="Account (name or ID)")
            bill_name = gr.Textbox(label="Bill Name")
            bill_amt = gr.Number(label="Amount", value=0.0)
            bill_due = gr.Textbox(label="Due Date (YYYY-MM-DD)")
            bill_repeat = gr.Dropdown(label="Repeat", choices=["none","monthly","yearly"], value="none")
            add_bill_btn = gr.Button("Add Bill")
            add_bill_out = gr.Textbox(label="Result", interactive=False)
            add_bill_btn.click(fn=ui_add_bill, inputs=[bill_acct, bill_name, bill_amt, bill_due, bill_repeat], outputs=add_bill_out)
        with gr.Row():
            days_ahead = gr.Slider(label="Show bills due in next N days", minimum=1, maximum=365, value=14)
            upcoming_btn = gr.Button("Show Upcoming Bills")
            upcoming_out = gr.Textbox(label="Upcoming Bills", interactive=False)
            upcoming_btn.click(fn=ui_upcoming_bills, inputs=[days_ahead], outputs=upcoming_out)
        with gr.Row():
            mark_bid = gr.Number(label="Bill ID to mark notified", value=0)
            mark_bill_btn = gr.Button("Mark Bill Notified")
            mark_bill_out = gr.Textbox(label="Result", interactive=False)
            mark_bill_btn.click(fn=ui_mark_bill, inputs=[mark_bid], outputs=mark_bill_out)

    with gr.Tab("Savings & Planning"):
        with gr.Row():
            goal_name = gr.Textbox(label="Goal Name")
            goal_target = gr.Number(label="Target Amount", value=0.0)
            goal_date = gr.Textbox(label="Target Date (YYYY-MM-DD) - optional")
            goal_acct = gr.Textbox(label="Account to save into (optional)")
            create_goal_btn = gr.Button("Create Savings Goal")
            create_goal_out = gr.Textbox(label="Result", interactive=False)
            create_goal_btn.click(fn=ui_create_goal, inputs=[goal_name, goal_target, goal_date, goal_acct], outputs=create_goal_out)
        with gr.Row():
            deposit_goal_id = gr.Number(label="Goal ID", value=0)
            deposit_amount = gr.Number(label="Amount", value=0.0)
            deposit_goal_btn = gr.Button("Deposit to Goal (just records, doesn't move account balance)")
            deposit_goal_out = gr.Textbox(label="Result", interactive=False)
            deposit_goal_btn.click(fn=ui_deposit_goal, inputs=[deposit_goal_id, deposit_amount], outputs=deposit_goal_out)
        with gr.Row():
            list_goals_btn = gr.Button("List Savings Goals")
            list_goals_out = gr.Textbox(label="Goals", interactive=False)
            list_goals_btn.click(fn=ui_list_goals, inputs=None, outputs=list_goals_out)
            proj_goal_id = gr.Number(label="Goal ID to project", value=0)
            proj_btn = gr.Button("Project Savings Rate")
            proj_out = gr.Textbox(label="Projection", interactive=False)
            proj_btn.click(fn=ui_project_goal, inputs=[proj_goal_id], outputs=proj_out)

    with gr.Tab("Natural-language Commands (optional)"):
        nl_text = gr.Textbox(label="Enter command (e.g., 'Add a bill of 500 for Internet due 2025-12-01 to my Savings account')", lines=2)
        nl_btn = gr.Button("Parse & Execute (NLP)")
        nl_out = gr.Textbox(label="Result", interactive=False)
        nl_btn.click(fn=ui_parse_nl_and_execute, inputs=[nl_text, hf_token_input], outputs=nl_out)

    gr.Markdown("Data stored in SQLite DB at `/content/pfinance_chatbot.db`. Download via Colab file browser if needed.")

# Launch the app
demo.launch(share=True, debug=False)

# -------------------
# Install dependencies
# -------------------
!pip -q install gradio pandas sqlalchemy requests

# -------------------
# Imports & config
# -------------------
import os, re, json, datetime
from pathlib import Path
from typing import Optional, Dict, Any
import pandas as pd
import requests
import gradio as gr
from sqlalchemy import create_engine, Column, Integer, String, Float, Date, DateTime, Table, MetaData, select, and_, func

DB_PATH = "/content/pfinance_chatbot.db"
HF_MODEL = "ibm-granite/granite-3.3-2b-instruct"
HF_API_URL = f"https://api-inference.huggingface.co/models/{HF_MODEL}"

# -------------------
# Setup SQLite DB
# -------------------
engine = create_engine(f"sqlite:///{DB_PATH}", connect_args={"check_same_thread": False})
meta = MetaData()

accounts_table = Table(
    "accounts", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("name", String, nullable=False, unique=True),
    Column("type", String),
    Column("balance", Float, nullable=False)
)

bills_table = Table(
    "bills", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("account_id", Integer, nullable=False),
    Column("name", String, nullable=False),
    Column("amount", Float, nullable=False),
    Column("due_date", Date, nullable=False),
    Column("repeat", String),
    Column("notified", Integer, nullable=False, default=0)
)

savings_goals_table = Table(
    "savings_goals", meta,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("name", String, nullable=False),
    Column("target_amount", Float, nullable=False),
    Column("current_amount", Float, nullable=False, default=0.0),
    Column("target_date", Date),
    Column("account_id", Integer)
)

meta.create_all(engine)

# -------------------
# Helper functions
# -------------------
def create_account(name: str, acc_type: str = "bank", initial_balance: float = 0.0) -> str:
    name = (name or "").strip()
    if not name:
        return "Account name required."

    with engine.begin() as conn:
        stmt = select(accounts_table.c.id).where(func.lower(accounts_table.c.name) == name.lower())
        exists = conn.execute(stmt).fetchone()
        if exists:
            return f"Account '{name}' already exists."

        conn.execute(
            accounts_table.insert().values(
                name=name,
                type=acc_type,
                balance=float(initial_balance)
            )
        )

    return f"Account '{name}' created with balance ₹{float(initial_balance):,.2f}"

def list_accounts() -> str:
    with engine.connect() as conn:
        rows = conn.execute(select(accounts_table)).fetchall()

    if not rows:
        return "No accounts yet."

    out = []
    for r in rows:
        r = r._mapping
        out.append(
            f"ID:{r['id']} | {r['name']} ({r['type']}) | Balance: ₹{r['balance']:,.2f}"
        )
    return "\n".join(out)

def get_account_by_name_or_id(identifier):
    if identifier is None:
        return None
    identifier = str(identifier).strip()

    with engine.connect() as conn:
        if identifier.isdigit():
            row = conn.execute(
                select(accounts_table).where(accounts_table.c.id == int(identifier))
            ).fetchone()
        else:
            row = conn.execute(
                select(accounts_table).where(func.lower(accounts_table.c.name) == identifier.lower())
            ).fetchone()

    return row._mapping if row else None

def update_account_balance(account_id: int, delta: float):
    with engine.begin() as conn:
        row = conn.execute(
            select(accounts_table.c.balance).where(accounts_table.c.id == account_id)
        ).fetchone()
        if not row:
            raise ValueError("Account not found")

        new_balance = float(row.balance) + float(delta)
        conn.execute(
            accounts_table.update()
            .where(accounts_table.c.id == account_id)
            .values(balance=new_balance)
        )
    return new_balance

# -------------------
# Bills
# -------------------
def add_bill(account_identifier, name, amount, due_date_str, repeat=None):
    acct = get_account_by_name_or_id(account_identifier)
    if not acct:
        return f"Account '{account_identifier}' not found."

    try:
        due = pd.to_datetime(due_date_str).date()
    except:
        return "Invalid date."

    with engine.begin() as conn:
        conn.execute(
            bills_table.insert().values(
                account_id=acct["id"],
                name=name,
                amount=float(amount),
                due_date=due,
                repeat=repeat,
                notified=0
            )
        )

    return f"Bill '{name}' added for account '{acct['name']}'"

def upcoming_bills(days):
    today = datetime.date.today()
    end = today + datetime.timedelta(days=int(days))

    with engine.connect() as conn:
        rows = conn.execute(
            select(
                bills_table.c.id,
                bills_table.c.name,
                bills_table.c.amount,
                bills_table.c.due_date,
                accounts_table.c.name.label("account_name")
            )
            .select_from(bills_table.join(accounts_table, bills_table.c.account_id == accounts_table.c.id))
            .where(and_(bills_table.c.due_date >= today, bills_table.c.due_date <= end))
            .order_by(bills_table.c.due_date)
        ).fetchall()

    if not rows:
        return "No upcoming bills."

    out = []
    for r in rows:
        r = r._mapping
        out.append(
            f"ID:{r['id']} | {r['name']} | {r['account_name']} | {r['due_date']} | ₹{r['amount']:,.2f}"
        )
    return "\n".join(out)

def mark_bill_notified(bill_id):
    with engine.begin() as conn:
        r = conn.execute(select(bills_table).where(bills_table.c.id == bill_id)).fetchone()
        if not r:
            return "Bill not found."

        conn.execute(
            bills_table.update().where(bills_table.c.id == bill_id).values(notified=1)
        )
    return f"Bill {bill_id} marked notified."

# -------------------
# Savings
# -------------------
def create_savings_goal(name, target_amount, target_date=None, account_identifier=None):
    acct = None
    if account_identifier:
        acct = get_account_by_name_or_id(account_identifier)
        if not acct:
            return f"Account '{account_identifier}' not found."

    try:
        td = pd.to_datetime(target_date).date() if target_date else None
    except:
        return "Invalid target date."

    with engine.begin() as conn:
        conn.execute(
            savings_goals_table.insert().values(
                name=name,
                target_amount=float(target_amount),
                current_amount=0.0,
                target_date=td,
                account_id=acct["id"] if acct else None
            )
        )

    return f"Savings goal '{name}' created."

def deposit_to_goal(goal_id, amount):
    with engine.begin() as conn:
        row = conn.execute(
            select(savings_goals_table).where(savings_goals_table.c.id == goal_id)
        ).fetchone()

        if not row:
            return "Goal not found."

        row = row._mapping
        new_amt = row["current_amount"] + float(amount)

        conn.execute(
            savings_goals_table.update()
            .where(savings_goals_table.c.id == goal_id)
            .values(current_amount=new_amt)
        )

    return f"Deposited ₹{amount:,.2f} to goal '{row['name']}'"

def list_goals():
    with engine.connect() as conn:
        rows = conn.execute(select(savings_goals_table)).fetchall()

    if not rows:
        return "No goals yet."

    out = []
    for r in rows:
        r = r._mapping
        td = r["target_date"] or "N/A"
        out.append(
            f"ID:{r['id']} | {r['name']} | ₹{r['current_amount']:,.2f} / ₹{r['target_amount']:,.2f} | Target:{td}"
        )
    return "\n".join(out)

def project_savings_rate(goal_id):
    with engine.connect() as conn:
        r = conn.execute(
            select(savings_goals_table).where(savings_goals_table.c.id == goal_id)
        ).fetchone()

    if not r:
        return "Goal not found."

    r = r._mapping
    if not r["target_date"]:
        return "Goal has no target date."

    today = datetime.date.today()
    months = max(1, (r["target_date"].year - today.year) * 12 + (r["target_date"].month - today.month))

    remaining = r["target_amount"] - r["current_amount"]
    per_month = remaining / months

    return f"Required saving: ₹{per_month:,.2f}/month"

# -------------------
# Gradio UI
# -------------------
def ui_create_account(n, t, b):
    return create_account(n, t, b)

def ui_list_accounts():
    return list_accounts()

def ui_add_bill(a, n, am, d, r):
    r = None if r == "none" else r
    return add_bill(a, n, am, d, r)

def ui_upcoming_bills(x):
    return upcoming_bills(x)

def ui_mark_bill(x):
    return mark_bill_notified(int(x))

def ui_create_goal(n, t, d, a):
    return create_savings_goal(n, t, d or None, a or None)

def ui_deposit_goal(i, a):
    return deposit_to_goal(i, a)

def ui_list_goals():
    return list_goals()

def ui_project_goal(i):
    return project_savings_rate(i)

# -------------------
# UI LAYOUT
# -------------------
with gr.Blocks() as demo:
    gr.Markdown("## Personal Finance Chatbot (Accounts Fixed)")

    with gr.Tab("Accounts"):
        acct_name = gr.Textbox(label="Name")
        acct_type = gr.Textbox(label="Type", value="bank")
        acct_bal = gr.Number(label="Initial Balance", value=0.0)
        btn = gr.Button("Create Account")
        out = gr.Textbox(label="Output")
        btn.click(ui_create_account, [acct_name, acct_type, acct_bal], out)

        btn2 = gr.Button("List Accounts")
        out2 = gr.Textbox(label="Accounts")
        btn2.click(ui_list_accounts, None, out2)

    with gr.Tab("Bills"):
        a = gr.Textbox(label="Account")
        bn = gr.Textbox(label="Bill Name")
        am = gr.Number(label="Amount")
        dd = gr.Textbox(label="Due Date (YYYY-MM-DD)")
        rp = gr.Dropdown(["none","monthly","yearly"], value="none", label="Repeat")
        btn3 = gr.Button("Add Bill")
        out3 = gr.Textbox()
        btn3.click(ui_add_bill, [a,bn,am,dd,rp], out3)

        days = gr.Slider(1,365,14)
        btn4 = gr.Button("Show Upcoming Bills")
        out4 = gr.Textbox()
        btn4.click(ui_upcoming_bills, days, out4)

        bid = gr.Number(label="Bill ID")
        btn5 = gr.Button("Mark Notified")
        out5 = gr.Textbox()
        btn5.click(ui_mark_bill, bid, out5)

    with gr.Tab("Goals"):
        g1 = gr.Textbox(label="Goal Name")
        g2 = gr.Number(label="Target")
        g3 = gr.Textbox(label="Target Date")
        g4 = gr.Textbox(label="Account")
        btn6 = gr.Button("Create Goal")
        out6 = gr.Textbox()
        btn6.click(ui_create_goal, [g1,g2,g3,g4], out6)

        gid = gr.Number(label="Goal ID")
        dam = gr.Number(label="Amount")
        btn7 = gr.Button("Deposit")
        out7 = gr.Textbox()
        btn7.click(ui_deposit_goal, [gid, dam], out7)

        btn8 = gr.Button("List Goals")
        out8 = gr.Textbox()
        btn8.click(ui_list_goals, None, out8)

        gid2 = gr.Number(label="Goal ID")
        btn9 = gr.Button("Project")
        out9 = gr.Textbox()
        btn9.click(ui_project_goal, gid2, out9)

demo.launch(share=True)